<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Infrastructure Test</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #00ffc8;
      padding: 20px;
      line-height: 1.6;
    }
    h1 {
      color: #ff0096;
      border-bottom: 2px solid #ff0096;
      padding-bottom: 10px;
    }
    h2 {
      color: #6464ff;
      margin-top: 30px;
    }
    .test {
      background: rgba(0, 255, 200, 0.05);
      border: 1px solid rgba(0, 255, 200, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
    }
    .test.pass {
      border-color: #00ffc8;
      background: rgba(0, 255, 200, 0.1);
    }
    .test.fail {
      border-color: #ff0096;
      background: rgba(255, 0, 150, 0.1);
    }
    .test-name {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .pass .test-name::before {
      content: '✓ ';
      color: #00ffc8;
    }
    .fail .test-name::before {
      content: '✗ ';
      color: #ff0096;
    }
    .result {
      margin-left: 20px;
      opacity: 0.8;
    }
    #summary {
      background: rgba(100, 100, 255, 0.1);
      border: 2px solid #6464ff;
      border-radius: 8px;
      padding: 20px;
      margin-top: 30px;
      font-size: 18px;
    }
    .error {
      color: #ff0096;
      background: rgba(255, 0, 150, 0.1);
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <h1>🧪 Event Infrastructure Test Suite</h1>
  <p>Testing Event Bus, App State, and Event Constants...</p>

  <div id="test-results"></div>
  <div id="summary"></div>

  <script type="module">
    import { eventBus } from './src/js/core/event-bus.js';
    import { appState } from './src/js/core/app-state.js';
    import { EVENTS } from './src/js/core/events.js';

    const results = [];
    const resultsContainer = document.getElementById('test-results');
    const summaryContainer = document.getElementById('summary');

    function addTest(name, passed, details) {
      results.push({ name, passed, details });
      const testDiv = document.createElement('div');
      testDiv.className = `test ${passed ? 'pass' : 'fail'}`;
      testDiv.innerHTML = `
        <div class="test-name">${name}</div>
        <div class="result">${details}</div>
      `;
      resultsContainer.appendChild(testDiv);
    }

    function showSummary() {
      const passed = results.filter(r => r.passed).length;
      const failed = results.filter(r => !r.passed).length;
      const total = results.length;

      summaryContainer.innerHTML = `
        <strong>Test Summary</strong><br>
        Total: ${total} | Passed: <span style="color: #00ffc8">${passed}</span> | Failed: <span style="color: #ff0096">${failed}</span><br>
        ${failed === 0 ? '<br>🎉 All tests passed! Infrastructure is ready.' : '<br>⚠️ Some tests failed. Check the results above.'}
      `;
    }

    // Enable debug mode for testing
    eventBus.setDebugMode(true);
    appState.setDebugMode(true);

    console.log('🧪 Starting Event Infrastructure Tests...\n');

    // ==========================================
    // Test 1: Event Bus - Basic Subscribe/Emit
    // ==========================================
    try {
      let test1Result = null;
      const unsubscribe1 = eventBus.on('test:event', (data) => {
        test1Result = data.message;
      });

      eventBus.emit('test:event', { message: 'Hello from Event Bus!' });

      if (test1Result === 'Hello from Event Bus!') {
        addTest('Event Bus: Subscribe & Emit', true, `Received: "${test1Result}"`);
      } else {
        addTest('Event Bus: Subscribe & Emit', false, `Expected "Hello from Event Bus!", got "${test1Result}"`);
      }

      unsubscribe1();
    } catch (error) {
      addTest('Event Bus: Subscribe & Emit', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 2: Event Bus - Once Handler
    // ==========================================
    try {
      let onceCount = 0;
      eventBus.once('test:once', () => {
        onceCount++;
      });

      eventBus.emit('test:once');
      eventBus.emit('test:once'); // Should not trigger again

      if (onceCount === 1) {
        addTest('Event Bus: Once Handler', true, `Handler called ${onceCount} time (correct)`);
      } else {
        addTest('Event Bus: Once Handler', false, `Handler called ${onceCount} times (should be 1)`);
      }
    } catch (error) {
      addTest('Event Bus: Once Handler', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 3: Event Bus - Multiple Subscribers
    // ==========================================
    try {
      let count = 0;
      const unsub1 = eventBus.on('test:multi', () => count++);
      const unsub2 = eventBus.on('test:multi', () => count++);
      const unsub3 = eventBus.on('test:multi', () => count++);

      eventBus.emit('test:multi');

      if (count === 3) {
        addTest('Event Bus: Multiple Subscribers', true, `All 3 handlers called (count: ${count})`);
      } else {
        addTest('Event Bus: Multiple Subscribers', false, `Expected 3 handlers, got ${count}`);
      }

      unsub1();
      unsub2();
      unsub3();
    } catch (error) {
      addTest('Event Bus: Multiple Subscribers', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 4: Event Bus - Unsubscribe
    // ==========================================
    try {
      let unsubCount = 0;
      const unsubTest = eventBus.on('test:unsub', () => unsubCount++);

      eventBus.emit('test:unsub'); // Should increment
      unsubTest(); // Unsubscribe
      eventBus.emit('test:unsub'); // Should NOT increment

      if (unsubCount === 1) {
        addTest('Event Bus: Unsubscribe', true, `Handler properly unsubscribed (count: ${unsubCount})`);
      } else {
        addTest('Event Bus: Unsubscribe', false, `Expected 1, got ${unsubCount}`);
      }
    } catch (error) {
      addTest('Event Bus: Unsubscribe', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 5: Event Bus - Error Handling
    // ==========================================
    try {
      let errorHandled = false;
      let successCalled = false;

      // Subscribe a handler that throws
      eventBus.on('test:error', () => {
        throw new Error('Intentional test error');
      });

      // Subscribe a handler that should still run
      eventBus.on('test:error', () => {
        successCalled = true;
      });

      // Emit - should not crash
      eventBus.emit('test:error');

      if (successCalled) {
        addTest('Event Bus: Error Handling', true, 'Other handlers continued after error');
      } else {
        addTest('Event Bus: Error Handling', false, 'Error prevented other handlers from running');
      }
    } catch (error) {
      addTest('Event Bus: Error Handling', false, `Uncaught error: ${error.message}`);
    }

    // ==========================================
    // Test 6: App State - Get/Set
    // ==========================================
    try {
      appState.set('timer.isRunning', true);
      const isRunning = appState.get('timer.isRunning');

      if (isRunning === true) {
        addTest('App State: Get/Set', true, `Value correctly set and retrieved: ${isRunning}`);
      } else {
        addTest('App State: Get/Set', false, `Expected true, got ${isRunning}`);
      }
    } catch (error) {
      addTest('App State: Get/Set', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 7: App State - Nested Paths
    // ==========================================
    try {
      appState.set('music.volume', 75);
      appState.set('music.currentTrack', 'test-video-id');

      const volume = appState.get('music.volume');
      const track = appState.get('music.currentTrack');

      if (volume === 75 && track === 'test-video-id') {
        addTest('App State: Nested Paths', true, `volume: ${volume}, track: ${track}`);
      } else {
        addTest('App State: Nested Paths', false, `Unexpected values: volume=${volume}, track=${track}`);
      }
    } catch (error) {
      addTest('App State: Nested Paths', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 8: App State - Change Notifications
    // ==========================================
    try {
      let changeReceived = false;
      let oldVal, newVal;

      const unsub = appState.subscribe('timer.currentTime', ({ value, oldValue }) => {
        changeReceived = true;
        oldVal = oldValue;
        newVal = value;
      });

      appState.set('timer.currentTime', 120);

      if (changeReceived && newVal === 120) {
        addTest('App State: Change Notifications', true, `Change detected: ${oldVal} → ${newVal}`);
      } else {
        addTest('App State: Change Notifications', false, `Change not detected properly`);
      }

      unsub();
    } catch (error) {
      addTest('App State: Change Notifications', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 9: App State - Update Function
    // ==========================================
    try {
      appState.set('music.volume', 50);
      appState.update('music.volume', (current) => current + 10);

      const updatedVolume = appState.get('music.volume');

      if (updatedVolume === 60) {
        addTest('App State: Update Function', true, `50 + 10 = ${updatedVolume}`);
      } else {
        addTest('App State: Update Function', false, `Expected 60, got ${updatedVolume}`);
      }
    } catch (error) {
      addTest('App State: Update Function', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 10: Event Constants - Availability
    // ==========================================
    try {
      const hasTimerEvents = EVENTS.TIMER_STARTED && EVENTS.TIMER_PAUSED && EVENTS.TIMER_COMPLETED;
      const hasMusicEvents = EVENTS.MUSIC_PLAYING && EVENTS.MUSIC_STOPPED && EVENTS.MUSIC_TRACK_CHANGED;
      const hasUIEvents = EVENTS.UI_PANEL_OPENED && EVENTS.UI_LIBRARY_OPENED;

      const eventCount = Object.keys(EVENTS).length;

      if (hasTimerEvents && hasMusicEvents && hasUIEvents && eventCount > 50) {
        addTest('Event Constants: Availability', true, `${eventCount} event constants defined`);
      } else {
        addTest('Event Constants: Availability', false, `Missing expected events or insufficient count: ${eventCount}`);
      }
    } catch (error) {
      addTest('Event Constants: Availability', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 11: Event Constants - Frozen
    // ==========================================
    try {
      const originalValue = EVENTS.TIMER_STARTED;
      let errorThrown = false;

      try {
        EVENTS.TIMER_STARTED = 'modified-value';
      } catch (e) {
        errorThrown = true;
      }

      const stillOriginal = EVENTS.TIMER_STARTED === originalValue;

      if (stillOriginal) {
        addTest('Event Constants: Immutable', true, 'EVENTS object is properly frozen');
      } else {
        addTest('Event Constants: Immutable', false, 'EVENTS object can be modified (should be frozen)');
      }
    } catch (error) {
      addTest('Event Constants: Immutable', false, `Error: ${error.message}`);
    }

    // ==========================================
    // Test 12: Integration - Real-world Scenario
    // ==========================================
    try {
      let timerStartEventReceived = false;
      let stateChangeReceived = false;

      // UI module listening for timer start
      eventBus.on(EVENTS.TIMER_STARTED, ({ startTime }) => {
        timerStartEventReceived = true;
        console.log('Timer started event received:', startTime);
      });

      // UI module listening for state changes
      appState.subscribe('timer.isRunning', ({ value }) => {
        stateChangeReceived = true;
        console.log('Timer state changed:', value);
      });

      // Timer module starts
      appState.set('timer.isRunning', true);
      eventBus.emit(EVENTS.TIMER_STARTED, { startTime: Date.now() });

      if (timerStartEventReceived && stateChangeReceived) {
        addTest('Integration: Real-world Scenario', true, 'Event and state communication working');
      } else {
        addTest('Integration: Real-world Scenario', false, `Event: ${timerStartEventReceived}, State: ${stateChangeReceived}`);
      }
    } catch (error) {
      addTest('Integration: Real-world Scenario', false, `Error: ${error.message}`);
    }

    // Show summary
    showSummary();

    // Disable debug mode
    eventBus.setDebugMode(false);
    appState.setDebugMode(false);

    console.log('\n✅ Test suite completed!');
    console.log(`Check the page for detailed results.`);
  </script>
</body>
</html>
